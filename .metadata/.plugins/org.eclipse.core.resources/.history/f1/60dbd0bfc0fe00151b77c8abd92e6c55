package com.cathacks2016.proxy.networking;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.util.HashMap;
import java.util.Vector;

import com.cathacks2016.proxy.networking.ssl.SSLClientSession;

public class ThreadedServerBucket {

	private ServerSocketChannel server_socket_channel;
	private HashMap<String, ServerBucket> buckets = new HashMap<>();
	private int next_thread_id = 0;
	
	public ThreadedServerBucket( ServerSocketChannel server_socket_channel ) {
		this.server_socket_channel = server_socket_channel;
		
		// Create base thread
		ServerBucket initial_bucket = new ServerBucket();
		buckets.put( initial_bucket.getName(), initial_bucket );
		initial_bucket.start();
		
	}
	
	private class ServerBucket extends Thread{
		
		public static final int CAPACITY = 100;
		private final Vector<SSLClientSession> connections = new Vector<>();
		private Selector server_selector;
		
		public ServerBucket() {
			super("Communication Server Thread ("+(next_thread_id++)+")");

			try {
				server_socket_channel.register(server_selector = Selector.open(), SelectionKey.OP_ACCEPT);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
		@Override
		public void run(){
			while( true ){

				try {
					/*count = */server_selector.select();
				} catch (IOException e1) {
					System.out.println("Selector has been closed.");
					return;
				}
					
//				if(count > 0)
//					OutputHandler.println("Communication Server: "+count+" selected.");
				/*
				 * Iterate through the server_selector selected keys
				 * to see if any channels are IO ready
				 */
				for(SelectionKey key: server_selector.selectedKeys()) {
					if(!key.isValid()) continue;
					
					try {
						
						if(key.isValid() && key.isAcceptable()) {
							handleAccept(key);
						}
						
						if(key.isValid() && key.isReadable()) {
							handleRead(key);
						}
						
						if(key.isValid() && key.isWritable()) {
							
							SSLClientSession session = (SSLClientSession)key.attachment();
							if(session.rewrite)
								handleWrite(key, null, session);
							else {
								handleWrite(key, session.out_messages.remove(), session);
//								OutputHandler.println("Messages left: "+session.out_messages.size());
							}
						} 
						
					} catch (IOException exc) {
						removeKeyAndSession(key);
					}
				}
				
				server_selector.selectedKeys().clear();
			}
			
			try {
				server_selector.close();
				System.out.println(this.getName()+" thread stopped.");
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
	}
	
}
